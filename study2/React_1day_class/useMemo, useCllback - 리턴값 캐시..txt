const [winNumbers, setWinNumbers] = useState(getWinNumbers());

=> function 컴포넌트는 전체가 다시 시작되기때문에, 밖에 함수인 getWinNumbers() 도 다시 시작됨.

만약, getWinNumbers() 가 90초 이상 걸리는 함수라면, 같은 함수가 반복되면서 시작되기때문에.
문제가 생기는데

const lottoNumbers = useMemo(() => getWinNumbers(),[]);
const [winNumbers, setWinNumbers] = useState(lottoNumbers());

이렇게 useMemo 를 해두면, 1번 캐싱하고 끝나기때문에, 괜춘.


const onClickRedo = () => {
        setWinNumbers(getWinNumbers());
        setWinBalls([]);
        setBonus(null);
        setRedo(false);
       
        timeouts.current = [];
    }


const onClickRedo = useCallback(() => {
        setWinNumbers(getWinNumbers());
        setWinBalls([]);
        setBonus(null);
        setRedo(false);
       
        timeouts.current = [];
    }, []);
    

이렇게 useCallback 으로 감싸면, 함수자체를 기억해서, 다시 구성하지 않음. 메모리제이션
문제는 재 실행시에도 
console.log(winNumbers); 이랬을때
값이 계속 똑같은게 찍힘.


 const onClickRedo = useCallback(() => {
        console.log(winNumbers);
        setWinNumbers(getWinNumbers());
        setWinBalls([]);
        setBonus(null);
        setRedo(false);
       
        timeouts.current = [];
    }, [winNumbers]);

이럼됨.


필수적으로 useCallback 을 해야할때는,
자식컴포넌트에게 함수를 넘길때다.


 {winBalls.map((v) => <Ball key={v} number={v} onClick={onClickRedo} />)}

useMemo는 리턴값을 기억한다.
useCallback 는 함수를 기억